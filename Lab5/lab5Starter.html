<!DOCTYPE html>
<html>
  <!-- Import Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <head>
    <meta charset="UTF-8" />
    <title></title>
    <style type="text/css"></style>
  </head>

  <body>
    <h1>CIAN BARRETT</h1>
    <script type="text/javascript">
      class Sphere {
        constructor(scene, xPos, yPos) {
          this.yVelocity = 1;
          this.xVelocity = 1;
          this.gravity = 0.05;

          this.scene = scene;

          var material = new THREE.MeshLambertMaterial({
            color: 0xffff00,
            wireframe: false,
          });
          var geometry = new THREE.SphereGeometry(20);
          this.sphere = new THREE.Mesh(geometry, material);

          // Enable shadow casting for the sphere
          this.sphere.castShadow = true;
          this.sphere.position.set(xPos, yPos, 0); // Ensure the sphere is centered
          this.scene.add(this.sphere);
        }

        move() {
          this.yVelocity += this.gravity;

          this.sphere.position.y -= this.yVelocity;
          // this.sphere.position.x += this.xVelocity;

          this.sphere.rotation.x += 0.01;
          this.sphere.rotation.y -= 0.01;
        }

        checkSphereCollision(secondSphere) {
          var distance = Math.sqrt(
            Math.pow(
              this.sphere.position.x - secondSphere.sphere.position.x,
              2
            ) +
              Math.pow(
                this.sphere.position.y - secondSphere.sphere.position.y,
                2
              )
          );

          if (distance <= 40) {
            this.xVelocity = this.xVelocity * -1;
            this.yVelocity = this.yVelocity * -1;

            console.log("spherecollion");

            // secondSphere.xVelocity*= -1;
            secondSphere.yVelocity *= -1;
          }
        }

        checkCollisions(planeY) {
          if (this.sphere.position.y - 20 <= planeY) {
            this.sphere.position.y = planeY + 20;
            this.yVelocity = this.yVelocity * -1;
            console.log("collision");
          }
        }
      }

      // Create the scene and camera
      var scene = new THREE.Scene();
      var camera = new THREE.PerspectiveCamera(
        80,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const planeGeometry = new THREE.PlaneGeometry(100, 100);
      const planeMaterial = new THREE.MeshLambertMaterial({
        color: 0x00ff00,
        side: THREE.DoubleSide,
      });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);

      plane.receiveShadow = true;
      plane.position.y = -30;
      plane.rotation.x = Math.PI / 2;
      scene.add(plane);

      var renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      var spotlight = new THREE.SpotLight(0xffffff);
      spotlight.castShadow = true;

      spotlight.shadow.camera.near = 10;
      spotlight.shadow.camera.far = 200;
      spotlight.shadow.camera.fov = 30;

      spotlight.position.set(50, 50, 50); // Position light above and to the side
      scene.add(spotlight);

      camera.position.z = 100;
      camera.position.y = 20;

      var sphere = new Sphere(scene, 0, 90);
      var sphere2 = new Sphere(scene, 0, 40);

      var repeatme = function () {
        renderer.render(scene, camera);
        requestAnimationFrame(repeatme);
        sphere.move();
        sphere2.move();

        sphere2.checkCollisions(plane.position.y);
        sphere.checkCollisions(plane.position.y);

        sphere.checkSphereCollision(sphere2);
      };
      repeatme();
    </script>
  </body>
</html>
